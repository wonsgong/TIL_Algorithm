# 문제 별 풀이.

## [11725 트리의 부모 찾기](./11725_트리의부모찾기.py)
입력으로 주어지는 연결된 두 정점을 인접리스트로 만들어서 bfs or dfs 돌려주면 된다. 

## [1167 트리의 지름 , 1967 트리의 지름](./1167_트리의지름.py)
트리의 지름 구하는 방법.  
1. 트리에서 임의의 정점 x를 잡는다.  
2. 정점 x에서 가장 먼 정점 y를 찾는다.  
3. 정점 y에서 가장 먼 정점 z를 찾는다.  
4. 트리의 지름은 정점 y 와 정점 z 를 연결하는 경로다.  
증명은 잘 설명되어 있는 블로그 참고 [링크](https://blog.myungwoo.kr/112).  
정점이 오름차순으로 입력될 거라 생각하고 코드를 짰다가 조금 헤맸다. -> 문제를 정확하게 읽고 풀자.  

## [1991 트리 순회](./1991_트리순회.py)
전위 순회, 중위 순회, 후위 순회를 재귀로 구현해주면 되는 문제.  
**언제 node를 방문하는 지**를 생각하고 출력해주면 된다.  
노드 명이 문자열이라 어떻게 처리할지 고민했는데 dict 로 해주면 쉽게 되는 거였다...ㅜ.  

## [2263 트리의 순회](./2263_트리의순회.py)
2개의 순회를 가지고 나머지 하나의 순회를 찾는 방법.  
1. root 찾기.(전위-[0],후위-[-1]).  
2. left, right 로 분할. -> 중위 기준 L < root.idx < R.  
여기서 주의할 점 : root 가 포함되지 않게 잘 넘겨주어야 한다.  
3. 1-2번 반복.  
4. 출력의 경우 찾아야 하는 순회에 따라 위치 조정.  
`list.index` 속도가 상당히 느리다. -> 따로 리스트 만들어서 쓰자.  
파라미터로 리스트 자체 보다는 `index` 를 넘기는 게 효율적이다.  
`RecursionError` -> `sys.setrecursionlimit(int(1e6))` 로 해결.  

## [5639 이진검색트리](./5639_이진검색트리.py)
직접 node 를 만들어서 트리를 구현 후 후위 순회를 돌리니 *시간초과*가 뜬다.(C++에선 통과됨ㅋ).  
root 값보다 작으면 왼쪽, 크면 오른쪽을 이용해서 왼쪽 서브트리, 오른쪽 서브트리로 나눠서 재귀로 품.(`setrecursionlimit`함수 필요).  
인풋의 개수를 모르는 경우 -> `python`은 `try/except` 활용. `c++`은 `EOF` 활용.  

## [4803 트리](./4803_트리.py)
트리 구조란 여러 노드가 한 노드를 가리킬수 없는 구조. 간단하게 사이클이 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리라고 부른다.(위키 내용).  
-> 유향 트리 : 간선 == 정점 - 1. 무향 트리 : 간선 / 2 == 정점 - 1.  
즉, **간선 / 2 == 정점 - 1** 을 만족하는 그래프를 찾아주면 된다.  